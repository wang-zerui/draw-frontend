(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-7f0932fa"],{"9b3b":function(e,n,t){"use strict";t("c743")},b3c3:function(e,n,t){"use strict";t.r(n);var l=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"hello"},[t("a-row",{staticStyle:{margin:"0 -12px"}},[t("a-col",{staticStyle:{padding:"0 12px"},attrs:{xl:12,lg:24,md:24,sm:24,xs:24}},[t("a-card",{attrs:{bodyStyle:{height:"800px","padding-right":"1px","padding-left":"1px","padding-top":"1px","padding-bottom":"0px"},title:"Parser.py"}},[t("codemirror",{attrs:{options:e.cmOptions},model:{value:e.code,callback:function(n){e.code=n},expression:"code"}})],1)],1),t("a-col",{staticStyle:{padding:"0 12px"},attrs:{xl:12,lg:24,md:24,sm:24,xs:24}},[t("a-card",{attrs:{bodyStyle:{height:"800px","padding-right":"1px","padding-left":"1px","padding-top":"1px","padding-bottom":"0px"},title:"ExprNode.py"}},[t("codemirror",{attrs:{options:e.cmOptions},model:{value:e.code1,callback:function(n){e.code1=n},expression:"code1"}})],1)],1)],1)],1)},s=[],o=(t("db91"),t("b866"),t("31c5"),t("10b2"),t("4ba6"),t("8c33"),t("7289"),t("2aed"),t("d72f"),t("b933"),t("0b6c"),t("2e6e"),{name:"Parser",data:function(){return{code1:"import Token\n\n# 定义二元操作符集\nbiOpList = [Token.TokenType.PLUS, Token.TokenType.MINUS, Token.TokenType.MUL,\n            Token.TokenType.DIV, Token.TokenType.POWER]\n\n\nclass ExprNode:\n    def __init__(self, operator):\n        self.operator = operator\n        # 二元运算符类型，左右子节点\n        if self.operator in biOpList:\n            self.left = None\n            self.right = None\n        # 函数类型，函数指针+单子节点\n        elif self.operator == Token.TokenType.FUNC:\n            self.funcPtr = None\n            self.son = None\n        self.value = None\n\n    # 字符串转换,含重写\n    def __str__(self):\n        return str(self.operator)\n\n    # 不同操作符运算不同\n    def eval(self):\n        if self.operator == Token.TokenType.PLUS:\n            self.value = self.right.value + self.left.value\n        elif self.operator == Token.TokenType.MINUS:\n            self.value = self.left.value - self.right.value\n        elif self.operator == Token.TokenType.MUL:\n            self.value = self.right.value * self.left.value\n        elif self.operator == Token.TokenType.DIV:\n            if self.right.value != 0:\n                self.value = self.left.value / self.right.value\n        elif self.operator == Token.TokenType.POWER:\n            self.value = self.left.value ** self.right.value\n        elif self.operator == Token.TokenType.FUNC:\n            v = self.son.value\n            fp = self.funcPtr(v)\n            self.value = fp\n        return self.value\n",code:'import numpy as np\nimport Token as TK\nimport ExprNode\n\ncolorList = ["DIMGRAY", "GOLDENROD", "KHAKI", "DARKSEAGREEN",\n             "DARKKHAKI", "PINK", "LIGHTSALMON", "LIGHTCORAL"]\nltList = ["DOTS", "DASHED", "SOLID"]\n\n\nclass Parser:\n    def __init__(self,lexer):\n        # 定义初始化变量（语法分析器内部）\n        self.lexer = lexer  # 词法分析器\n        self.token = None\n        self.param = 0\n        self.x_origin, self.y_origin = 0, 0\n        self.x_scale, self.y_scale = 1, 1\n        self.rot = 0\n        self.color, self.lineWidth, self.lineType = None, 2, "SOLID"\n        self.x_label, self.y_label = "", ""\n        self.title = ""\n        self.gridOn, self.dynamicOn = 0, 0\n        self.x_ptr, self.y_ptr = None, None\n        self.tValue = 0\n        self.radius = None\n\n    def start(self,x):  # 进入语句\n        self.radius = None\n        print("start", str(x))\n\n    def end(self,x):  # 离开语句\n        print("end", str(x))\n\n    def callMatch(self,x):  # 匹配token类型\n        print(\'match token\', str(x))\n\n    def toString(self, x):  # 打印语法树\n        self.PrintTree(x, 1)\n\n    def PrintTree(self, root, indent):  # 打印语法树\n        for i in range(indent):  # 控制树缩进\n            print(\'\t\', end=\' \')\n        if root.operator == TK.TokenType.PLUS:\n            print(\'+ \')\n        elif root.operator == TK.TokenType.MINUS:\n            print(\'- \')\n        elif root.operator == TK.TokenType.MUL:\n            print(\'* \')\n        elif root.operator == TK.TokenType.DIV:\n            print("/ ")\n        elif root.operator == TK.TokenType.POWER:\n            print("** ")\n        elif root.operator == TK.TokenType.FUNC:\n            print("{} ".format(root.funcPtr))\n        elif root.operator == TK.TokenType.CONST_ID:\n            print(\'{:5f} \'.format(root.value))\n        elif root.operator == TK.TokenType.T:\n            print(\'{} \'.format(root.value))\n        else:\n            print("Invalid Type!")\n            raise Exception("出错行号：", self.lexer.index, " Invalid type ")\n        if root.operator == TK.TokenType.CONST_ID or root.operator == TK.TokenType.T:\n            return  # 常数和参数是叶子节点\n        elif root.operator == TK.TokenType.FUNC:\n            self.PrintTree(root.son, indent + 1)  # 函数只有一个孩子节点\n        # 递归先序遍历\n        else:\n            self.PrintTree(root.left, indent + 1)\n            self.PrintTree(root.right, indent + 1)\n\n    # 根据当前的单词值，处理初等项（最高优先级）\n    def prim(self):  # 识别一个标识符或数字、或括号内\n        if self.token.tokenType == TK.TokenType.PLUS:\n            self.match(TK.TokenType.PLUS)\n            right = self.prim()\n            left = None\n            right = self.makeBiNode(TK.TokenType.PLUS, left, right)\n        elif self.token.tokenType == TK.TokenType.MINUS:\n            self.match(TK.TokenType.MINUS)\n            right = self.prim()\n            left = ExprNode.ExprNode(TK.TokenType.CONST_ID)\n            left.value = 0.0\n            right = self.makeBiNode(TK.TokenType.MINUS, left, right)\n        else:\n            right = self.component()\n        return right\n\n    # 处理*和/，并返回表达式结果，乘、除的优先级高于加、减(包含了负号)\n    def term(self):\n        left = self.prim()\n        while self.token.tokenType == TK.TokenType.MUL or self.token.tokenType == TK.TokenType.DIV:\n            temp = self.token.tokenType\n            self.match(temp)\n            right = self.prim()\n            left = self.makeBiNode(temp, left, right)\n        return left\n\n    # 处理 + 和 -，并返回表达式结果\n    def expr(self):\n        self.start("Expression")\n        left = self.term()\n        while self.token.tokenType == TK.TokenType.PLUS or self.token.tokenType == TK.TokenType.MINUS:\n            temp = self.token.tokenType\n            self.match(temp)\n            right = self.term()\n            left = self.makeBiNode(temp, left, right)\n        self.toString(left)\n        self.end("Expression")\n        return left\n\n    # 处理幂关系\n    def component(self):\n        left = self.atom()\n        if self.token.tokenType == TK.TokenType.POWER:\n            self.match(TK.TokenType.POWER)\n            right = self.component()\n            left = self.makeBiNode(TK.TokenType.POWER, left, right)\n        return left\n\n    # 识别函数、常数、参数\n    def atom(self):\n        if self.token.tokenType == TK.TokenType.CONST_ID:\n            temp = self.token.value\n            self.match(TK.TokenType.CONST_ID)\n            address = self.makeUnNode(TK.TokenType.CONST_ID, temp)\n        elif self.token.tokenType == TK.TokenType.T:\n            self.match(TK.TokenType.T)\n            if len(self.Tvalue) == 1:\n                address = self.makeUnNode(TK.TokenType.T, 0.0)\n            else:\n                address = self.makeUnNode(TK.TokenType.T, self.Tvalue)\n        elif self.token.tokenType == TK.TokenType.FUNC:\n            temp_ptr = self.token.function\n            self.match(TK.TokenType.FUNC)\n            self.match(TK.TokenType.L_BRACKET)\n            self.callMatch("(")\n            temp = self.expr()\n            address = self.makeBiNode(TK.TokenType.FUNC, temp_ptr, temp)\n            self.match(TK.TokenType.R_BRACKET)\n            self.callMatch(")")\n        elif self.token.tokenType == TK.TokenType.L_BRACKET:\n            self.match(TK.TokenType.L_BRACKET)\n            self.callMatch("(")\n            address = self.expr()\n            self.match(TK.TokenType.R_BRACKET)\n            self.callMatch(")")\n        else:\n            print(self.token.tokenType)\n            raise Exception("出错行号：", self.lexer.index, " 与期望记号不符 ", self.token.lexeme, "Atom")\n        return address\n\n    # 生成含二元子树节点\n    def makeBiNode(self, op, left, right):\n        ExprPtr = ExprNode.ExprNode(op)\n        if op == TK.TokenType.FUNC:\n            ExprPtr.funcPtr = left\n            ExprPtr.son = right\n        else:\n            ExprPtr.left = left\n            ExprPtr.right = right\n        ExprPtr.eval()\n        return ExprPtr\n\n    # 生成含一元子树节点\n    def makeUnNode(self, op, value):  # 常数和变量的节点，叶子结点\n        ExprPtr = ExprNode.ExprNode(op)\n        ExprPtr.value = value\n        return ExprPtr\n\n    # 移进分析函数，通过分支\n    def move(self):\n        self.start("Statement")\n        if self.token.tokenType == TK.TokenType.ORIGIN:\n            self.originStat()\n        elif self.token.tokenType == TK.TokenType.SCALE:\n            self.scaleStat()\n        elif self.token.tokenType == TK.TokenType.FOR:\n            self.forStat()\n            self.recordLine()\n        elif self.token.tokenType == TK.TokenType.ROT:\n            self.rotStat()\n        elif self.token.tokenType == TK.TokenType.TITLE:\n            self.titleStat()\n        elif self.token.tokenType == TK.TokenType.XLABEL:\n            self.xLabelStat()\n        elif self.token.tokenType == TK.TokenType.YLABEL:\n            self.yLabelStat()\n        elif self.token.tokenType == TK.TokenType.GRID:\n            self.gridStat()\n        elif self.token.tokenType == TK.TokenType.DYNAMIC:\n            self.dynamicStat()\n        elif self.token.tokenType == TK.TokenType.SEMICO:\n            self.emptyStat()\n        elif self.token.tokenType in [TK.TokenType.CONST_ID, TK.TokenType.L_BRACKET, TK.TokenType.MINUS]:\n            self.expr()\n        else:\n            print(self.token.tokenType)\n            raise Exception("出错行号：", self.lexer.index, " 与期望记号不符 ", self.token.lexeme, "Move")\n        self.end("Statement")\n\n    def match(self, token_type):  # 匹配token符号，带出错处理\n        if self.token.tokenType != token_type:\n            print(self.token.tokenType)\n            raise Exception("出错行号：", self.lexer.index, " 与期望记号不符 ", token_type, self.token.lexeme, "Match")\n        self.get()\n\n    def get(self):           \n        # 调用getToken()方法\n        # 设置当前token\n        self.token = self.lexer.getToken()\n        # 如果出错则报错\n        if self.token == TK.TokenType.ERRORTOKEN:\n            print(self.token.tokenType)\n            raise Exception("出错行号：", self.lexer.index, " 记号错误 ", self.lexer.lexeme, "Get")\n\n    def parser(self):  # 语法分析器本体\n        self.start("Parser")\n        if self.lexer.file_ptr is None:\n            print("文件打开错误")\n        else:\n            self.get()  # 获取第一个token\n            self.program()  # 开始递归下降分析\n            self.lexer.__del__()  # 关闭词法分析器\n            self.end("Parser")  # 退出语法分析器\n\n    def program(self):\n        self.start("Program")\n        while self.token.tokenType != TK.TokenType.NONTOKEN:\n            self.move()\n            self.match(TK.TokenType.SEMICO)\n            self.callMatch(";")\n        self.end("Program")\n\n    def originStat(self):      # origin语句\n        self.start("OriginStatement")\n        self.match(TK.TokenType.ORIGIN)\n        self.callMatch("ORIGIN")\n        self.match(TK.TokenType.IS)\n        self.callMatch("IS")\n        self.match(TK.TokenType.L_BRACKET)\n\n        self.callMatch("(")\n        temp = self.expr()\n        self.x_origin = temp.eval()\n        self.match(TK.TokenType.COMMA)\n        self.callMatch(",")\n        temp = self.expr()\n        self.y_origin = temp.eval()\n        self.match(TK.TokenType.R_BRACKET)\n        self.callMatch(")")\n        self.end("OriginStatement")\n\n    def scaleStat(self):   # scale语句\n        self.start("ScaleStatement")\n        self.match(TK.TokenType.SCALE)\n        self.callMatch("SCALE")\n        self.match(TK.TokenType.IS)\n        self.callMatch("IS")\n\n        self.match(TK.TokenType.L_BRACKET)\n        self.callMatch("(")\n        temp = self.expr()\n        self.x_scale = temp.eval()\n        self.match(TK.TokenType.COMMA)\n        self.callMatch(",")\n        temp = self.expr()\n        self.y_scale = temp.eval()\n        self.y_origin = temp.eval()\n        self.match(TK.TokenType.R_BRACKET)\n        self.callMatch(")")\n        self.end("ScaleStatement")\n\n    def forStat(self):     # for-draw语句\n        self.start("ForStatement")\n        self.match(TK.TokenType.FOR)\n        self.callMatch("FOR")\n        self.match(TK.TokenType.T)\n        self.callMatch("T")\n        self.match(TK.TokenType.FROM)\n        self.callMatch("FROM")\n        start_ptr = self.expr()\n        start_v = start_ptr.eval()\n        self.match(TK.TokenType.TO)\n        self.callMatch("TO")\n        end_ptr = self.expr()\n        end_v = end_ptr.eval()\n        self.match(TK.TokenType.STEP)\n        self.callMatch("STEP")\n        step_ptr = self.expr()\n        step_v = step_ptr.eval()\n        self.Tvalue = np.arange(start_v, end_v, step_v)\n\n        if self.token.tokenType == TK.TokenType.DRAW:\n            self.match(TK.TokenType.DRAW)\n            self.callMatch("DRAW")\n            self.match(TK.TokenType.L_BRACKET)\n            self.callMatch("(")\n            v1 = self.expr().value\n            self.x_ptr = v1\n            self.match(TK.TokenType.COMMA)\n            self.callMatch(",")\n            v2 = self.expr().value\n            self.y_ptr = v2\n            self.match(TK.TokenType.R_BRACKET)\n            self.callMatch(")")\n\n            if self.token.tokenType == TK.TokenType.IN:\n                self.match(TK.TokenType.IN)\n                self.callMatch("IN")\n                if str(self.token.lexeme) in colorList:\n                    self.color = self.token.lexeme\n                self.match(TK.TokenType.COLOR)\n                self.callMatch(self.color)\n\n            if self.token.tokenType == TK.TokenType.LINE:\n                self.match(TK.TokenType.LINE)\n                self.callMatch("LINE")\n                # 数字类\n                if self.token.tokenType in [TK.TokenType.CONST_ID, TK.TokenType.L_BRACKET, TK.TokenType.MINUS]:\n                    lineWidth_ptr = self.expr()\n                    self.lineWidth = lineWidth_ptr.eval()\n\n                # 字型类\n                if str(self.token.lexeme) in ltList:\n                    lt = str(self.token.lexeme)\n                    self.match(TK.TokenType.LINE_TYPE)\n                    self.callMatch(lt)\n                    self.lineType = lt\n\n        elif self.token.tokenType == TK.TokenType.SCATTER:\n            self.match(TK.TokenType.SCATTER)\n            self.callMatch("SCATTER")\n            self.match(TK.TokenType.L_BRACKET)\n            self.callMatch("(")\n            v1 = self.expr().value\n            self.x_ptr = v1\n            self.match(TK.TokenType.COMMA)\n            self.callMatch(",")\n            v2 = self.expr().value\n            self.y_ptr = v2\n            self.match(TK.TokenType.COMMA)\n            self.callMatch(",")\n            v3 = self.expr().value\n            self.radius = v3\n            self.match(TK.TokenType.R_BRACKET)\n            self.callMatch(")")\n            self.lineType = "scatter"\n            if self.token.tokenType == TK.TokenType.IN:\n                self.match(TK.TokenType.IN)\n                self.callMatch("IN")\n                if str(self.token.lexeme) in colorList:\n                    self.color = self.token.lexeme\n                self.match(TK.TokenType.COLOR)\n                self.callMatch(self.color)\n\n        self.end("ForStatement")\n\n    def rotStat(self):     # rot语句\n        self.start("RotStatement")\n        self.match(TK.TokenType.ROT)\n        self.callMatch("ROT")\n        self.match(TK.TokenType.IS)\n        self.callMatch("IS")\n        temp = self.expr()\n        self.rot = temp.eval()\n        self.end("RotStatement")\n\n    def titleStat(self):\n        self.start("TitleStatement")\n        self.match(TK.TokenType.TITLE)\n        self.callMatch("TITLE")\n        self.title = self.token.lexeme\n        self.match(TK.TokenType.USER_STRING)\n        self.callMatch(self.title)\n        self.end("TitleStatement")\n\n    def xLabelStat(self):\n        self.start("XLabelStatement")\n        self.match(TK.TokenType.XLABEL)\n        self.callMatch("XLABEL")\n        self.x_label = self.token.lexeme\n        self.match(TK.TokenType.USER_STRING)\n        self.callMatch(self.x_label)\n        self.end("XLabelStatement")\n\n    def yLabelStat(self):\n        self.start("YLabelStatement")\n        self.match(TK.TokenType.YLABEL)\n        self.callMatch("YLABEL")\n        self.y_label = self.token.lexeme\n        self.match(TK.TokenType.USER_STRING)\n        self.callMatch(self.y_label)\n        self.end("YLabelStatement")\n\n    def gridStat(self):\n        self.start("GridStatement")\n        self.match(TK.TokenType.GRID)\n        self.callMatch("GRID")\n\n        if self.token.tokenType == TK.TokenType.ON:\n            self.gridOn = 1\n            self.match(TK.TokenType.ON)\n            self.callMatch("ON")\n        elif self.token.tokenType == TK.TokenType.OFF:\n            self.gridOn = 0\n            self.match(TK.TokenType.OFF)\n            self.callMatch("OFF")\n        self.end("GridStatement")\n\n    def dynamicStat(self):\n        self.start("DynamicStatement")\n        self.match(TK.TokenType.DYNAMIC)\n        self.callMatch("DYNAMIC")\n        if self.token.tokenType == TK.TokenType.ON:\n            self.dynamicOn = 1\n            self.match(TK.TokenType.ON)\n            self.callMatch("ON")\n        elif self.token.tokenType == TK.TokenType.OFF:\n            self.dynamicOn = 0\n            self.match(TK.TokenType.OFF)\n            self.callMatch("OFF")\n        self.end("DynamicStatement")\n\n    def emptyStat(self):\n        self.start("EmptyStatement")\n        self.end("EmptyStatement")\n\n    def recordLine(self):\n        pass',cmOptions:{autoCloseBrackets:!0,tabSize:4,styleActiveLine:!0,lineNumbers:!0,line:!0,mode:"text/x-python",theme:"idea",keyMap:"emacs"},option:{},updateOption:{},isImage:!1,isError:!1,isSuccess:!1,errorMsg:"",successMsg:"",collapsed:!1}},methods:{onCmReady:function(e){console.log("the editor is readied!",e)},onCmFocus:function(e){console.log("the editor is focused!",e)},onCmCodeChange:function(e){console.log("this is new code",e),this.code=e}},computed:{},mounted:function(){},components:{}}),f=o,T=(t("9b3b"),t("2877")),a=Object(T["a"])(f,l,s,!1,null,null,null);n["default"]=a.exports},c743:function(e,n,t){}}]);
//# sourceMappingURL=chunk-7f0932fa.aa76dc9e.js.map