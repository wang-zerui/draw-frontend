{"version":3,"sources":["webpack:///./src/components/Parser.vue?8c5a","webpack:///./src/components/Parser.vue?7f62","webpack:///src/components/Parser.vue","webpack:///./src/components/Parser.vue?d266","webpack:///./src/components/Parser.vue?7e62"],"names":["render","_vm","this","_h","$createElement","_c","_self","staticClass","staticStyle","attrs","height","cmOptions","model","value","callback","$$v","code","expression","code1","staticRenderFns","name","data","autoCloseBrackets","tabSize","styleActiveLine","lineNumbers","line","mode","theme","keyMap","option","updateOption","isImage","isError","isSuccess","errorMsg","successMsg","collapsed","methods","onCmReady","console","log","cm","onCmFocus","onCmCodeChange","newCode","computed","mounted","components","component"],"mappings":"kHAAA,W,yCCAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,YAAY,SAAS,CAACF,EAAG,QAAQ,CAACG,YAAY,CAAC,OAAS,YAAY,CAACH,EAAG,QAAQ,CAACG,YAAY,CAAC,QAAU,UAAUC,MAAM,CAAC,GAAK,GAAG,GAAK,GAAG,GAAK,GAAG,GAAK,GAAG,GAAK,KAAK,CAACJ,EAAG,SAAS,CAACI,MAAM,CAAC,UAAY,CACpSC,OAAQ,QACR,gBAAiB,MACjB,eAAgB,MAChB,cAAe,MACf,iBAAkB,OAClB,MAAQ,cAAc,CAACL,EAAG,aAAa,CAACI,MAAM,CAAC,QAAUR,EAAIU,WAAWC,MAAM,CAACC,MAAOZ,EAAQ,KAAEa,SAAS,SAAUC,GAAMd,EAAIe,KAAKD,GAAKE,WAAW,WAAW,IAAI,GAAGZ,EAAG,QAAQ,CAACG,YAAY,CAAC,QAAU,UAAUC,MAAM,CAAC,GAAK,GAAG,GAAK,GAAG,GAAK,GAAG,GAAK,GAAG,GAAK,KAAK,CAACJ,EAAG,SAAS,CAACI,MAAM,CAAC,UAAY,CACnSC,OAAQ,QACR,gBAAiB,MACjB,eAAgB,MAChB,cAAe,MACf,iBAAkB,OAClB,MAAQ,gBAAgB,CAACL,EAAG,aAAa,CAACI,MAAM,CAAC,QAAUR,EAAIU,WAAWC,MAAM,CAACC,MAAOZ,EAAS,MAAEa,SAAS,SAAUC,GAAMd,EAAIiB,MAAMH,GAAKE,WAAW,YAAY,IAAI,IAAI,IAAI,IACpLE,EAAkB,GCyDtB,G,wHAAA,CACEC,KAAM,SACNC,KAFF,WAGI,MAAO,CACLH,MAAO,+6CA2CPF,KAAM,qjeA6aNL,UAAW,CACTW,mBAAmB,EACnBC,QAAS,EACTC,iBAAiB,EACjBC,aAAa,EACbC,MAAM,EACNC,KAAM,gBACNC,MAAO,OACPC,OAAQ,SAEVC,OAAQ,GACRC,aAAc,GACdC,SAAS,EACTC,SAAS,EACTC,WAAW,EACXC,SAAU,GACVC,WAAY,GACZC,WAAW,IAGfC,QAAS,CACPC,UADJ,SACA,GACMC,QAAQC,IAAI,yBAA0BC,IAExCC,UAJJ,SAIA,GACMH,QAAQC,IAAI,yBAA0BC,IAExCE,eAPJ,SAOA,GACMJ,QAAQC,IAAI,mBAAoBI,GAChC3C,KAAKc,KAAO6B,IAGhBC,SAAU,GACVC,QA7fF,aA8fEC,WAAY,KCpkBkU,I,wBCQ5UC,EAAY,eACd,EACAjD,EACAmB,GACA,EACA,KACA,KACA,MAIa,aAAA8B,E","file":"js/chunk-7f0932fa.aa76dc9e.js","sourcesContent":["export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--7-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--7-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-2!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Parser.vue?vue&type=style&index=0&lang=css&\"","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"hello\"},[_c('a-row',{staticStyle:{\"margin\":\"0 -12px\"}},[_c('a-col',{staticStyle:{\"padding\":\"0 12px\"},attrs:{\"xl\":12,\"lg\":24,\"md\":24,\"sm\":24,\"xs\":24}},[_c('a-card',{attrs:{\"bodyStyle\":{\n          height: '800px',\n          'padding-right': '1px',\n          'padding-left': '1px',\n          'padding-top': '1px',\n          'padding-bottom': '0px',\n        },\"title\":\"Parser.py\"}},[_c('codemirror',{attrs:{\"options\":_vm.cmOptions},model:{value:(_vm.code),callback:function ($$v) {_vm.code=$$v},expression:\"code\"}})],1)],1),_c('a-col',{staticStyle:{\"padding\":\"0 12px\"},attrs:{\"xl\":12,\"lg\":24,\"md\":24,\"sm\":24,\"xs\":24}},[_c('a-card',{attrs:{\"bodyStyle\":{\n          height: '800px',\n          'padding-right': '1px',\n          'padding-left': '1px',\n          'padding-top': '1px',\n          'padding-bottom': '0px',\n        },\"title\":\"ExprNode.py\"}},[_c('codemirror',{attrs:{\"options\":_vm.cmOptions},model:{value:(_vm.code1),callback:function ($$v) {_vm.code1=$$v},expression:\"code1\"}})],1)],1)],1)],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <div class=\"hello\">\n    <a-row style=\"margin: 0 -12px\">\n      <a-col\n        style=\"padding: 0 12px\"\n        :xl=\"12\"\n        :lg=\"24\"\n        :md=\"24\"\n        :sm=\"24\"\n        :xs=\"24\"\n      >\n        <a-card\n          :bodyStyle=\"{\n            height: '800px',\n            'padding-right': '1px',\n            'padding-left': '1px',\n            'padding-top': '1px',\n            'padding-bottom': '0px',\n          }\"\n          title=\"Parser.py\"\n        >\n          <codemirror v-model=\"code\" :options=\"cmOptions\" />\n        </a-card>\n      </a-col>\n      <a-col\n        style=\"padding: 0 12px\"\n        :xl=\"12\"\n        :lg=\"24\"\n        :md=\"24\"\n        :sm=\"24\"\n        :xs=\"24\"\n      >\n        <a-card\n          :bodyStyle=\"{\n            height: '800px',\n            'padding-right': '1px',\n            'padding-left': '1px',\n            'padding-top': '1px',\n            'padding-bottom': '0px',\n          }\"\n          title=\"ExprNode.py\"\n        >\n          <codemirror v-model=\"code1\" :options=\"cmOptions\" />\n        </a-card>\n      </a-col>\n    </a-row>\n  </div>\n</template>\n<script>\n// language\nimport \"codemirror/mode/python/python.js\";\n\n// theme css\nimport \"codemirror/theme/idea.css\";\n\n// require active-line.js\nimport \"codemirror/addon/selection/active-line.js\";\n\n// closebrackets\nimport \"codemirror/addon/edit/closebrackets.js\";\n\n// keyMap\nimport \"codemirror/mode/clike/clike.js\";\nimport \"codemirror/addon/edit/matchbrackets.js\";\nimport \"codemirror/addon/comment/comment.js\";\nimport \"codemirror/addon/dialog/dialog.js\";\nimport \"codemirror/addon/dialog/dialog.css\";\nimport \"codemirror/addon/search/searchcursor.js\";\nimport \"codemirror/addon/search/search.js\";\nimport \"codemirror/keymap/emacs.js\";\nexport default {\n  name: \"Parser\",\n  data() {\n    return {\n      code1: `import Token\n\n# 定义二元操作符集\nbiOpList = [Token.TokenType.PLUS, Token.TokenType.MINUS, Token.TokenType.MUL,\n            Token.TokenType.DIV, Token.TokenType.POWER]\n\n\nclass ExprNode:\n    def __init__(self, operator):\n        self.operator = operator\n        # 二元运算符类型，左右子节点\n        if self.operator in biOpList:\n            self.left = None\n            self.right = None\n        # 函数类型，函数指针+单子节点\n        elif self.operator == Token.TokenType.FUNC:\n            self.funcPtr = None\n            self.son = None\n        self.value = None\n\n    # 字符串转换,含重写\n    def __str__(self):\n        return str(self.operator)\n\n    # 不同操作符运算不同\n    def eval(self):\n        if self.operator == Token.TokenType.PLUS:\n            self.value = self.right.value + self.left.value\n        elif self.operator == Token.TokenType.MINUS:\n            self.value = self.left.value - self.right.value\n        elif self.operator == Token.TokenType.MUL:\n            self.value = self.right.value * self.left.value\n        elif self.operator == Token.TokenType.DIV:\n            if self.right.value != 0:\n                self.value = self.left.value / self.right.value\n        elif self.operator == Token.TokenType.POWER:\n            self.value = self.left.value ** self.right.value\n        elif self.operator == Token.TokenType.FUNC:\n            v = self.son.value\n            fp = self.funcPtr(v)\n            self.value = fp\n        return self.value\n`,\n      code: `import numpy as np\nimport Token as TK\nimport ExprNode\n\ncolorList = [\"DIMGRAY\", \"GOLDENROD\", \"KHAKI\", \"DARKSEAGREEN\",\n             \"DARKKHAKI\", \"PINK\", \"LIGHTSALMON\", \"LIGHTCORAL\"]\nltList = [\"DOTS\", \"DASHED\", \"SOLID\"]\n\n\nclass Parser:\n    def __init__(self,lexer):\n        # 定义初始化变量（语法分析器内部）\n        self.lexer = lexer  # 词法分析器\n        self.token = None\n        self.param = 0\n        self.x_origin, self.y_origin = 0, 0\n        self.x_scale, self.y_scale = 1, 1\n        self.rot = 0\n        self.color, self.lineWidth, self.lineType = None, 2, \"SOLID\"\n        self.x_label, self.y_label = \"\", \"\"\n        self.title = \"\"\n        self.gridOn, self.dynamicOn = 0, 0\n        self.x_ptr, self.y_ptr = None, None\n        self.tValue = 0\n        self.radius = None\n\n    def start(self,x):  # 进入语句\n        self.radius = None\n        print(\"start\", str(x))\n\n    def end(self,x):  # 离开语句\n        print(\"end\", str(x))\n\n    def callMatch(self,x):  # 匹配token类型\n        print('match token', str(x))\n\n    def toString(self, x):  # 打印语法树\n        self.PrintTree(x, 1)\n\n    def PrintTree(self, root, indent):  # 打印语法树\n        for i in range(indent):  # 控制树缩进\n            print('\\t', end=' ')\n        if root.operator == TK.TokenType.PLUS:\n            print('+ ')\n        elif root.operator == TK.TokenType.MINUS:\n            print('- ')\n        elif root.operator == TK.TokenType.MUL:\n            print('* ')\n        elif root.operator == TK.TokenType.DIV:\n            print(\"/ \")\n        elif root.operator == TK.TokenType.POWER:\n            print(\"** \")\n        elif root.operator == TK.TokenType.FUNC:\n            print(\"{} \".format(root.funcPtr))\n        elif root.operator == TK.TokenType.CONST_ID:\n            print('{:5f} '.format(root.value))\n        elif root.operator == TK.TokenType.T:\n            print('{} '.format(root.value))\n        else:\n            print(\"Invalid Type!\")\n            raise Exception(\"出错行号：\", self.lexer.index, \" Invalid type \")\n        if root.operator == TK.TokenType.CONST_ID or root.operator == TK.TokenType.T:\n            return  # 常数和参数是叶子节点\n        elif root.operator == TK.TokenType.FUNC:\n            self.PrintTree(root.son, indent + 1)  # 函数只有一个孩子节点\n        # 递归先序遍历\n        else:\n            self.PrintTree(root.left, indent + 1)\n            self.PrintTree(root.right, indent + 1)\n\n    # 根据当前的单词值，处理初等项（最高优先级）\n    def prim(self):  # 识别一个标识符或数字、或括号内\n        if self.token.tokenType == TK.TokenType.PLUS:\n            self.match(TK.TokenType.PLUS)\n            right = self.prim()\n            left = None\n            right = self.makeBiNode(TK.TokenType.PLUS, left, right)\n        elif self.token.tokenType == TK.TokenType.MINUS:\n            self.match(TK.TokenType.MINUS)\n            right = self.prim()\n            left = ExprNode.ExprNode(TK.TokenType.CONST_ID)\n            left.value = 0.0\n            right = self.makeBiNode(TK.TokenType.MINUS, left, right)\n        else:\n            right = self.component()\n        return right\n\n    # 处理*和/，并返回表达式结果，乘、除的优先级高于加、减(包含了负号)\n    def term(self):\n        left = self.prim()\n        while self.token.tokenType == TK.TokenType.MUL or self.token.tokenType == TK.TokenType.DIV:\n            temp = self.token.tokenType\n            self.match(temp)\n            right = self.prim()\n            left = self.makeBiNode(temp, left, right)\n        return left\n\n    # 处理 + 和 -，并返回表达式结果\n    def expr(self):\n        self.start(\"Expression\")\n        left = self.term()\n        while self.token.tokenType == TK.TokenType.PLUS or self.token.tokenType == TK.TokenType.MINUS:\n            temp = self.token.tokenType\n            self.match(temp)\n            right = self.term()\n            left = self.makeBiNode(temp, left, right)\n        self.toString(left)\n        self.end(\"Expression\")\n        return left\n\n    # 处理幂关系\n    def component(self):\n        left = self.atom()\n        if self.token.tokenType == TK.TokenType.POWER:\n            self.match(TK.TokenType.POWER)\n            right = self.component()\n            left = self.makeBiNode(TK.TokenType.POWER, left, right)\n        return left\n\n    # 识别函数、常数、参数\n    def atom(self):\n        if self.token.tokenType == TK.TokenType.CONST_ID:\n            temp = self.token.value\n            self.match(TK.TokenType.CONST_ID)\n            address = self.makeUnNode(TK.TokenType.CONST_ID, temp)\n        elif self.token.tokenType == TK.TokenType.T:\n            self.match(TK.TokenType.T)\n            if len(self.Tvalue) == 1:\n                address = self.makeUnNode(TK.TokenType.T, 0.0)\n            else:\n                address = self.makeUnNode(TK.TokenType.T, self.Tvalue)\n        elif self.token.tokenType == TK.TokenType.FUNC:\n            temp_ptr = self.token.function\n            self.match(TK.TokenType.FUNC)\n            self.match(TK.TokenType.L_BRACKET)\n            self.callMatch(\"(\")\n            temp = self.expr()\n            address = self.makeBiNode(TK.TokenType.FUNC, temp_ptr, temp)\n            self.match(TK.TokenType.R_BRACKET)\n            self.callMatch(\")\")\n        elif self.token.tokenType == TK.TokenType.L_BRACKET:\n            self.match(TK.TokenType.L_BRACKET)\n            self.callMatch(\"(\")\n            address = self.expr()\n            self.match(TK.TokenType.R_BRACKET)\n            self.callMatch(\")\")\n        else:\n            print(self.token.tokenType)\n            raise Exception(\"出错行号：\", self.lexer.index, \" 与期望记号不符 \", self.token.lexeme, \"Atom\")\n        return address\n\n    # 生成含二元子树节点\n    def makeBiNode(self, op, left, right):\n        ExprPtr = ExprNode.ExprNode(op)\n        if op == TK.TokenType.FUNC:\n            ExprPtr.funcPtr = left\n            ExprPtr.son = right\n        else:\n            ExprPtr.left = left\n            ExprPtr.right = right\n        ExprPtr.eval()\n        return ExprPtr\n\n    # 生成含一元子树节点\n    def makeUnNode(self, op, value):  # 常数和变量的节点，叶子结点\n        ExprPtr = ExprNode.ExprNode(op)\n        ExprPtr.value = value\n        return ExprPtr\n\n    # 移进分析函数，通过分支\n    def move(self):\n        self.start(\"Statement\")\n        if self.token.tokenType == TK.TokenType.ORIGIN:\n            self.originStat()\n        elif self.token.tokenType == TK.TokenType.SCALE:\n            self.scaleStat()\n        elif self.token.tokenType == TK.TokenType.FOR:\n            self.forStat()\n            self.recordLine()\n        elif self.token.tokenType == TK.TokenType.ROT:\n            self.rotStat()\n        elif self.token.tokenType == TK.TokenType.TITLE:\n            self.titleStat()\n        elif self.token.tokenType == TK.TokenType.XLABEL:\n            self.xLabelStat()\n        elif self.token.tokenType == TK.TokenType.YLABEL:\n            self.yLabelStat()\n        elif self.token.tokenType == TK.TokenType.GRID:\n            self.gridStat()\n        elif self.token.tokenType == TK.TokenType.DYNAMIC:\n            self.dynamicStat()\n        elif self.token.tokenType == TK.TokenType.SEMICO:\n            self.emptyStat()\n        elif self.token.tokenType in [TK.TokenType.CONST_ID, TK.TokenType.L_BRACKET, TK.TokenType.MINUS]:\n            self.expr()\n        else:\n            print(self.token.tokenType)\n            raise Exception(\"出错行号：\", self.lexer.index, \" 与期望记号不符 \", self.token.lexeme, \"Move\")\n        self.end(\"Statement\")\n\n    def match(self, token_type):  # 匹配token符号，带出错处理\n        if self.token.tokenType != token_type:\n            print(self.token.tokenType)\n            raise Exception(\"出错行号：\", self.lexer.index, \" 与期望记号不符 \", token_type, self.token.lexeme, \"Match\")\n        self.get()\n\n    def get(self):           \n        # 调用getToken()方法\n        # 设置当前token\n        self.token = self.lexer.getToken()\n        # 如果出错则报错\n        if self.token == TK.TokenType.ERRORTOKEN:\n            print(self.token.tokenType)\n            raise Exception(\"出错行号：\", self.lexer.index, \" 记号错误 \", self.lexer.lexeme, \"Get\")\n\n    def parser(self):  # 语法分析器本体\n        self.start(\"Parser\")\n        if self.lexer.file_ptr is None:\n            print(\"文件打开错误\")\n        else:\n            self.get()  # 获取第一个token\n            self.program()  # 开始递归下降分析\n            self.lexer.__del__()  # 关闭词法分析器\n            self.end(\"Parser\")  # 退出语法分析器\n\n    def program(self):\n        self.start(\"Program\")\n        while self.token.tokenType != TK.TokenType.NONTOKEN:\n            self.move()\n            self.match(TK.TokenType.SEMICO)\n            self.callMatch(\";\")\n        self.end(\"Program\")\n\n    def originStat(self):      # origin语句\n        self.start(\"OriginStatement\")\n        self.match(TK.TokenType.ORIGIN)\n        self.callMatch(\"ORIGIN\")\n        self.match(TK.TokenType.IS)\n        self.callMatch(\"IS\")\n        self.match(TK.TokenType.L_BRACKET)\n\n        self.callMatch(\"(\")\n        temp = self.expr()\n        self.x_origin = temp.eval()\n        self.match(TK.TokenType.COMMA)\n        self.callMatch(\",\")\n        temp = self.expr()\n        self.y_origin = temp.eval()\n        self.match(TK.TokenType.R_BRACKET)\n        self.callMatch(\")\")\n        self.end(\"OriginStatement\")\n\n    def scaleStat(self):   # scale语句\n        self.start(\"ScaleStatement\")\n        self.match(TK.TokenType.SCALE)\n        self.callMatch(\"SCALE\")\n        self.match(TK.TokenType.IS)\n        self.callMatch(\"IS\")\n\n        self.match(TK.TokenType.L_BRACKET)\n        self.callMatch(\"(\")\n        temp = self.expr()\n        self.x_scale = temp.eval()\n        self.match(TK.TokenType.COMMA)\n        self.callMatch(\",\")\n        temp = self.expr()\n        self.y_scale = temp.eval()\n        self.y_origin = temp.eval()\n        self.match(TK.TokenType.R_BRACKET)\n        self.callMatch(\")\")\n        self.end(\"ScaleStatement\")\n\n    def forStat(self):     # for-draw语句\n        self.start(\"ForStatement\")\n        self.match(TK.TokenType.FOR)\n        self.callMatch(\"FOR\")\n        self.match(TK.TokenType.T)\n        self.callMatch(\"T\")\n        self.match(TK.TokenType.FROM)\n        self.callMatch(\"FROM\")\n        start_ptr = self.expr()\n        start_v = start_ptr.eval()\n        self.match(TK.TokenType.TO)\n        self.callMatch(\"TO\")\n        end_ptr = self.expr()\n        end_v = end_ptr.eval()\n        self.match(TK.TokenType.STEP)\n        self.callMatch(\"STEP\")\n        step_ptr = self.expr()\n        step_v = step_ptr.eval()\n        self.Tvalue = np.arange(start_v, end_v, step_v)\n\n        if self.token.tokenType == TK.TokenType.DRAW:\n            self.match(TK.TokenType.DRAW)\n            self.callMatch(\"DRAW\")\n            self.match(TK.TokenType.L_BRACKET)\n            self.callMatch(\"(\")\n            v1 = self.expr().value\n            self.x_ptr = v1\n            self.match(TK.TokenType.COMMA)\n            self.callMatch(\",\")\n            v2 = self.expr().value\n            self.y_ptr = v2\n            self.match(TK.TokenType.R_BRACKET)\n            self.callMatch(\")\")\n\n            if self.token.tokenType == TK.TokenType.IN:\n                self.match(TK.TokenType.IN)\n                self.callMatch(\"IN\")\n                if str(self.token.lexeme) in colorList:\n                    self.color = self.token.lexeme\n                self.match(TK.TokenType.COLOR)\n                self.callMatch(self.color)\n\n            if self.token.tokenType == TK.TokenType.LINE:\n                self.match(TK.TokenType.LINE)\n                self.callMatch(\"LINE\")\n                # 数字类\n                if self.token.tokenType in [TK.TokenType.CONST_ID, TK.TokenType.L_BRACKET, TK.TokenType.MINUS]:\n                    lineWidth_ptr = self.expr()\n                    self.lineWidth = lineWidth_ptr.eval()\n\n                # 字型类\n                if str(self.token.lexeme) in ltList:\n                    lt = str(self.token.lexeme)\n                    self.match(TK.TokenType.LINE_TYPE)\n                    self.callMatch(lt)\n                    self.lineType = lt\n\n        elif self.token.tokenType == TK.TokenType.SCATTER:\n            self.match(TK.TokenType.SCATTER)\n            self.callMatch(\"SCATTER\")\n            self.match(TK.TokenType.L_BRACKET)\n            self.callMatch(\"(\")\n            v1 = self.expr().value\n            self.x_ptr = v1\n            self.match(TK.TokenType.COMMA)\n            self.callMatch(\",\")\n            v2 = self.expr().value\n            self.y_ptr = v2\n            self.match(TK.TokenType.COMMA)\n            self.callMatch(\",\")\n            v3 = self.expr().value\n            self.radius = v3\n            self.match(TK.TokenType.R_BRACKET)\n            self.callMatch(\")\")\n            self.lineType = \"scatter\"\n            if self.token.tokenType == TK.TokenType.IN:\n                self.match(TK.TokenType.IN)\n                self.callMatch(\"IN\")\n                if str(self.token.lexeme) in colorList:\n                    self.color = self.token.lexeme\n                self.match(TK.TokenType.COLOR)\n                self.callMatch(self.color)\n\n        self.end(\"ForStatement\")\n\n    def rotStat(self):     # rot语句\n        self.start(\"RotStatement\")\n        self.match(TK.TokenType.ROT)\n        self.callMatch(\"ROT\")\n        self.match(TK.TokenType.IS)\n        self.callMatch(\"IS\")\n        temp = self.expr()\n        self.rot = temp.eval()\n        self.end(\"RotStatement\")\n\n    def titleStat(self):\n        self.start(\"TitleStatement\")\n        self.match(TK.TokenType.TITLE)\n        self.callMatch(\"TITLE\")\n        self.title = self.token.lexeme\n        self.match(TK.TokenType.USER_STRING)\n        self.callMatch(self.title)\n        self.end(\"TitleStatement\")\n\n    def xLabelStat(self):\n        self.start(\"XLabelStatement\")\n        self.match(TK.TokenType.XLABEL)\n        self.callMatch(\"XLABEL\")\n        self.x_label = self.token.lexeme\n        self.match(TK.TokenType.USER_STRING)\n        self.callMatch(self.x_label)\n        self.end(\"XLabelStatement\")\n\n    def yLabelStat(self):\n        self.start(\"YLabelStatement\")\n        self.match(TK.TokenType.YLABEL)\n        self.callMatch(\"YLABEL\")\n        self.y_label = self.token.lexeme\n        self.match(TK.TokenType.USER_STRING)\n        self.callMatch(self.y_label)\n        self.end(\"YLabelStatement\")\n\n    def gridStat(self):\n        self.start(\"GridStatement\")\n        self.match(TK.TokenType.GRID)\n        self.callMatch(\"GRID\")\n\n        if self.token.tokenType == TK.TokenType.ON:\n            self.gridOn = 1\n            self.match(TK.TokenType.ON)\n            self.callMatch(\"ON\")\n        elif self.token.tokenType == TK.TokenType.OFF:\n            self.gridOn = 0\n            self.match(TK.TokenType.OFF)\n            self.callMatch(\"OFF\")\n        self.end(\"GridStatement\")\n\n    def dynamicStat(self):\n        self.start(\"DynamicStatement\")\n        self.match(TK.TokenType.DYNAMIC)\n        self.callMatch(\"DYNAMIC\")\n        if self.token.tokenType == TK.TokenType.ON:\n            self.dynamicOn = 1\n            self.match(TK.TokenType.ON)\n            self.callMatch(\"ON\")\n        elif self.token.tokenType == TK.TokenType.OFF:\n            self.dynamicOn = 0\n            self.match(TK.TokenType.OFF)\n            self.callMatch(\"OFF\")\n        self.end(\"DynamicStatement\")\n\n    def emptyStat(self):\n        self.start(\"EmptyStatement\")\n        self.end(\"EmptyStatement\")\n\n    def recordLine(self):\n        pass`,\n      cmOptions: {\n        autoCloseBrackets: true,\n        tabSize: 4,\n        styleActiveLine: true,\n        lineNumbers: true,\n        line: true,\n        mode: \"text/x-python\",\n        theme: \"idea\",\n        keyMap: \"emacs\",\n      },\n      option: {},\n      updateOption: {},\n      isImage: false,\n      isError: false,\n      isSuccess: false,\n      errorMsg: \"\",\n      successMsg: \"\",\n      collapsed: false,\n    };\n  },\n  methods: {\n    onCmReady(cm) {\n      console.log(\"the editor is readied!\", cm);\n    },\n    onCmFocus(cm) {\n      console.log(\"the editor is focused!\", cm);\n    },\n    onCmCodeChange(newCode) {\n      console.log(\"this is new code\", newCode);\n      this.code = newCode;\n    },\n  },\n  computed: {},\n  mounted() {},\n  components: {},\n};\n</script>\n\n<style>\n.CodeMirror {\n  height: 800px !important;\n}\n.CodeMirror-focused .cm-matchhighlight {\n  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAYAAABytg0kAAAAFklEQVQI12NgYGBgkKzc8x9CMDAwAAAmhwSbidEoSQAAAABJRU5ErkJggg==);\n  background-position: bottom;\n  background-repeat: repeat-x;\n}\n.cm-matchhighlight {\n  background-color: lightgreen;\n}\n.CodeMirror-selection-highlight-scrollbar {\n  background-color: green;\n}\n</style>\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Parser.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Parser.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./Parser.vue?vue&type=template&id=88f54a9a&\"\nimport script from \"./Parser.vue?vue&type=script&lang=js&\"\nexport * from \"./Parser.vue?vue&type=script&lang=js&\"\nimport style0 from \"./Parser.vue?vue&type=style&index=0&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}